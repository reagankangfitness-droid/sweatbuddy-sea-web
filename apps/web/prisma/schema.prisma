generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Enums
enum ActivityType {
  RUN
  GYM
  YOGA
  HIKE
  CYCLING
  OTHER
}

// =====================================================
// ACTIVITY CATEGORY TAXONOMY SYSTEM
// =====================================================

model CategoryGroup {
  id           String   @id @default(cuid())
  slug         String   @unique
  name         String
  description  String?
  emoji        String?
  color        String? // hex color
  displayOrder Int      @default(0)
  isActive     Boolean  @default(true)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  categories ActivityCategory[]

  @@index([slug])
  @@index([isActive, displayOrder])
  @@map("category_groups")
}

model ActivityCategory {
  id           String   @id @default(cuid())
  slug         String   @unique
  name         String
  description  String?
  emoji        String?
  icon         String? // lucide icon name
  color        String? // hex color
  groupSlug    String?
  displayOrder Int      @default(0)
  isActive     Boolean  @default(true)
  isFeatured   Boolean  @default(false)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  group CategoryGroup? @relation(fields: [groupSlug], references: [slug])
  // Note: Activities use categorySlug as a plain string, not a foreign key
  // This allows us to manage categories as code constants while still
  // having the option to store category metadata in the database if needed

  @@index([slug])
  @@index([groupSlug])
  @@index([isActive, displayOrder])
  @@index([isFeatured])
  @@map("activity_categories")
}

enum ActivityStatus {
  DRAFT
  PENDING_APPROVAL
  PUBLISHED
  CANCELLED
  COMPLETED
}

enum UserActivityStatus {
  INTERESTED
  JOINED
  CANCELLED
  COMPLETED
}

enum GroupPrivacy {
  PUBLIC
  PRIVATE
}

enum UserRole {
  MEMBER
  ADMIN
}

enum NotificationType {
  MENTION
  MESSAGE
  ACTIVITY_UPDATE
  JOIN_REQUEST
  SYSTEM
}

// Models
model User {
  id        String    @id @default(cuid())
  email     String    @unique
  name      String?
  imageUrl  String?
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  // Profile fields
  username  String? @unique
  slug      String? @unique
  firstName String?
  bio       String?
  headline  String? @db.VarChar(200)
  location  String? @db.VarChar(200)

  // Social links
  website   String? @db.VarChar(500)
  instagram String? @db.VarChar(100)
  twitter   String? @db.VarChar(100)
  linkedin  String? @db.VarChar(200)
  tiktok    String? @db.VarChar(100)

  // Profile settings
  isHost                 Boolean @default(false)
  isVerified             Boolean @default(false)
  isPublic               Boolean @default(true)
  showActivitiesAttended Boolean @default(true)
  showStats              Boolean @default(true)

  // Trust & Safety
  accountStatus  UserAccountStatus @default(ACTIVE)
  suspendedUntil DateTime?

  // Host-specific fields
  hostSince      DateTime?
  specialties    String[]  @default([])
  certifications String[]  @default([])
  coverImage     String?   @db.VarChar(500)

  // Profile timestamps
  profileUpdatedAt DateTime?

  // Beta access fields
  betaAccessGranted    Boolean   @default(false)
  betaInviteCodeUsed   String?   @db.VarChar(20)
  betaInvitesRemaining Int       @default(3)
  betaJoinedAt         DateTime?

  activities              Activity[]              @relation("CreatedActivities")
  hostedActivities        Activity[]              @relation("HostedActivities")
  groups                  UserGroup[]
  messages                Message[]
  userActivities          UserActivity[]
  sentConversations       Conversation[]          @relation("SentConversations")
  receivedConversations   Conversation[]          @relation("ReceivedConversations")
  conversationMessages    ConversationMessage[]
  referralInvitesSent     ReferralInvite[]        @relation("ReferralInvitesSent")
  referralConversions     ReferralConversion[]    @relation("ReferralConversions")
  referralStats           UserReferralStats?
  workoutBuddiesAsUser    WorkoutBuddy[]          @relation("WorkoutBuddiesAsUser")
  workoutBuddiesAsBuddy   WorkoutBuddy[]          @relation("WorkoutBuddiesAsBuddy")
  notifications           Notification[]          @relation("UserNotifications")
  mentionsSent            Mention[]               @relation("MentionsSent")
  mentionsReceived        Mention[]               @relation("MentionsReceived")
  notificationPreferences NotificationPreference?

  // Host statistics relations
  hostStats           HostStats?         @relation("HostStats")
  hostActivityStats   ActivityStats[]    @relation("HostActivityStats")
  hostStatsDaily      HostStatsDaily[]   @relation("HostStatsDaily")
  hostStatsMonthly    HostStatsMonthly[] @relation("HostStatsMonthly")
  hostAttendeeHistory AttendeeHistory[]  @relation("HostAttendeeHistory")
  attendeeHistory     AttendeeHistory[]  @relation("AttendeeHistory")
  activityViews       ActivityView[]     @relation("UserActivityViews")

  // Profile relations
  followers       UserFollower[] @relation("UserFollowers")
  following       UserFollower[] @relation("UserFollowing")
  profileViews    ProfileView[]  @relation("ProfileViews")
  profileViewedBy ProfileView[]  @relation("ProfileViewers")

  // Beta system relations
  betaCodesCreated BetaInviteCode[] @relation("BetaCodesCreated")
  betaAccessLogs   BetaAccessLog[]  @relation("BetaAccessLogs")

  // Waitlist relations
  waitlistEntries ActivityWaitlist[] @relation("UserWaitlistEntries")

  // Review relations
  reviewsWritten    Review[]           @relation("ReviewsWritten")
  reviewsReceived   Review[]           @relation("ReviewsReceived")
  hostRatingSummary HostRatingSummary? @relation("HostRatingSummary")

  // Completion card relations
  completionCards CompletionCard[] @relation("UserCompletionCards")
  userStreaks     UserStreak[]     @relation("UserStreaks")

  // Event submissions (host applications)
  eventSubmissions EventSubmission[] @relation("UserEventSubmissions")

  // Wave mode
  waveActivitiesCreated WaveActivity[]    @relation("WaveActivitiesCreated")
  waveParticipations    WaveParticipant[] @relation("WaveParticipations")
  crewChatMemberships   CrewChatMember[]  @relation("CrewChatMemberships")
  crewMessagesSent      CrewMessage[]     @relation("CrewMessagesSent")

  // Trust & Safety relations
  reportsMade       UserReport[]    @relation("ReportsMade")
  reportsReceived   UserReport[]    @relation("ReportsReceived")
  blocksMade        UserBlock[]     @relation("BlocksMade")
  blocksReceived    UserBlock[]     @relation("BlocksReceived")
  moderationActions ModerationLog[] @relation("ModerationActions")

  // Community relations
  communitiesOwned        Community[]          @relation("CommunitiesOwned")
  communityMemberships    CommunityMember[]    @relation("CommunityMemberships")
  communityMessagesSent   CommunityMessage[]   @relation("CommunityMessagesSent")

  @@index([slug])
  @@index([username])
  @@index([isHost])
  @@index([isPublic])
  @@map("users")
}

model Activity {
  id             String         @id @default(cuid())
  title          String
  description    String?
  type           ActivityType // Legacy field - kept for backwards compatibility
  categorySlug   String? // New category system
  city           String
  latitude       Float
  longitude      Float
  // Additional location fields for Google Places data
  address        String? // Full formatted address (e.g., "Red Dot Design Museum, 11 Marina Blvd, Singapore 018940")
  streetAddress  String? // Street portion (e.g., "11 Marina Blvd")
  postalCode     String? // Postal/ZIP code
  country        String? // Country name
  placeId        String? // Google Places ID for reference
  neighborhoodId String? // Singapore neighborhood ID for map features
  startTime      DateTime?
  endTime        DateTime?
  maxPeople      Int?
  imageUrl       String?
  price          Float          @default(0)
  currency       String         @default("USD")
  status         ActivityStatus @default(PUBLISHED)
  userId         String
  hostId         String?
  createdAt      DateTime       @default(now())
  updatedAt      DateTime       @updatedAt
  deletedAt      DateTime?

  // Community link (optional - activity can belong to a community)
  communityId String?

  user            User             @relation("CreatedActivities", fields: [userId], references: [id])
  host            User?            @relation("HostedActivities", fields: [hostId], references: [id])
  community       Community?       @relation("CommunityActivities", fields: [communityId], references: [id])
  // Note: categorySlug is NOT a foreign key - categories are managed in code as constants
  // This allows flexibility to add/remove categories without database migrations
  userActivities  UserActivity[]
  groups          Group[]
  conversations   Conversation[]
  referralInvites ReferralInvite[]
  workoutBuddies  WorkoutBuddy[]

  // Statistics relations
  activityStats ActivityStats? @relation("ActivityStats")
  activityViews ActivityView[] @relation("ActivityViews")

  // Waitlist relations
  waitlistEntries ActivityWaitlist[]       @relation("ActivityWaitlist")
  urgencySettings ActivityUrgencySettings? @relation("ActivityUrgencySettings")

  // Review relations
  reviews       Review[]               @relation("ActivityReviews")
  ratingSummary ActivityRatingSummary? @relation("ActivityRatingSummary")

  @@index([userId])
  @@index([hostId])
  @@index([type])
  @@index([categorySlug])
  @@index([city])
  @@index([startTime])
  @@index([title])
  @@index([status])
  @@index([placeId])
  @@index([neighborhoodId])
  @@index([communityId])
  @@map("activities")
}

model Group {
  id          String       @id @default(cuid())
  name        String
  description String?
  privacy     GroupPrivacy @default(PUBLIC)
  activityId  String?
  createdAt   DateTime     @default(now())
  updatedAt   DateTime     @updatedAt
  deletedAt   DateTime?

  activity Activity?   @relation(fields: [activityId], references: [id])
  members  UserGroup[]
  messages Message[]

  @@index([activityId])
  @@map("groups")
}

model Message {
  id        String    @id @default(cuid())
  content   String
  groupId   String
  userId    String
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  group    Group     @relation(fields: [groupId], references: [id])
  user     User      @relation(fields: [userId], references: [id])
  mentions Mention[]

  @@index([groupId])
  @@index([userId])
  @@map("messages")
}

model UserGroup {
  id        String    @id @default(cuid())
  userId    String
  groupId   String
  role      UserRole  @default(MEMBER)
  joinedAt  DateTime  @default(now())
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  user  User  @relation(fields: [userId], references: [id])
  group Group @relation(fields: [groupId], references: [id])

  @@unique([userId, groupId])
  @@index([userId])
  @@index([groupId])
  @@map("user_groups")
}

// Payment status enum
enum PaymentStatus {
  PENDING
  PAID
  FAILED
  REFUNDED
  FREE
  EXPIRED
}

model UserActivity {
  id         String             @id @default(cuid())
  userId     String
  activityId String
  status     UserActivityStatus @default(INTERESTED)
  createdAt  DateTime           @default(now())
  updatedAt  DateTime           @updatedAt
  deletedAt  DateTime?

  // Payment tracking fields
  paymentStatus           PaymentStatus? @default(PENDING)
  stripeCheckoutSessionId String?
  stripePaymentIntentId   String?
  amountPaid              Float?
  currency                String?        @default("SGD")
  paidAt                  DateTime?
  refundedAt              DateTime?
  refundAmount            Float?

  user     User     @relation(fields: [userId], references: [id])
  activity Activity @relation(fields: [activityId], references: [id])
  payment  Payment?

  // Waitlist conversion tracking
  waitlistEntry ActivityWaitlist? @relation("WaitlistBooking")

  // Review relation (one review per booking)
  review Review? @relation("BookingReview")

  // Completion card relation
  completionCard CompletionCard? @relation("BookingCompletionCard")

  @@unique([userId, activityId])
  @@index([userId])
  @@index([activityId])
  @@index([status])
  @@index([stripeCheckoutSessionId])
  @@map("user_activities")
}

// Detailed payment tracking for audit trail
model Payment {
  id             String  @id @default(cuid())
  userActivityId String  @unique
  userId         String
  activityId     String
  hostId         String?

  // Stripe IDs
  stripeCheckoutSessionId String?
  stripePaymentIntentId   String?
  stripeCustomerId        String?

  // Payment details
  amount   Float
  currency String        @default("SGD")
  status   PaymentStatus @default(PENDING)

  // Fees tracking (for future use)
  stripeFee   Float?
  platformFee Float?
  hostPayout  Float?

  // Discount tracking
  originalAmount   Float?
  discountAmount   Float?
  discountCode     String?
  referralInviteId String?

  // Metadata
  description String?
  metadata    Json?

  // Timestamps
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  paidAt     DateTime?
  refundedAt DateTime?

  userActivity UserActivity @relation(fields: [userActivityId], references: [id])

  @@index([userId])
  @@index([activityId])
  @@index([stripeCheckoutSessionId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@map("payments")
}

model Conversation {
  id         String    @id @default(cuid())
  activityId String
  senderId   String
  receiverId String
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt
  deletedAt  DateTime?

  activity Activity              @relation(fields: [activityId], references: [id])
  sender   User                  @relation("SentConversations", fields: [senderId], references: [id])
  receiver User                  @relation("ReceivedConversations", fields: [receiverId], references: [id])
  messages ConversationMessage[]

  @@unique([activityId, senderId, receiverId])
  @@index([activityId])
  @@index([senderId])
  @@index([receiverId])
  @@map("conversations")
}

model ConversationMessage {
  id             String    @id @default(cuid())
  conversationId String
  userId         String
  content        String
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt
  deletedAt      DateTime?

  conversation Conversation @relation(fields: [conversationId], references: [id])
  user         User         @relation(fields: [userId], references: [id])

  @@index([conversationId])
  @@index([userId])
  @@map("conversation_messages")
}

// Referral System Models
enum ReferralInviteStatus {
  PENDING
  CLICKED
  CONVERTED
  EXPIRED
}

enum DiscountType {
  PERCENTAGE
  FIXED
  FREE
}

model ReferralInvite {
  id         String               @id @default(cuid())
  referrerId String
  activityId String
  inviteCode String               @unique
  inviteLink String
  status     ReferralInviteStatus @default(PENDING)

  friendEmail String?
  friendName  String?

  createdAt   DateTime  @default(now())
  expiresAt   DateTime
  clickedAt   DateTime?
  convertedAt DateTime?
  deletedAt   DateTime?

  referrerRewardClaimed Boolean @default(false)
  friendDiscountApplied Boolean @default(false)

  referrer    User                 @relation("ReferralInvitesSent", fields: [referrerId], references: [id])
  activity    Activity             @relation(fields: [activityId], references: [id])
  conversions ReferralConversion[]

  @@index([referrerId])
  @@index([activityId])
  @@index([inviteCode])
  @@index([status])
  @@map("referral_invites")
}

model ReferralConversion {
  id             String  @id @default(cuid())
  inviteId       String
  friendUserId   String
  userActivityId String?

  discountType   DiscountType
  discountValue  Float
  discountAmount Float

  convertedAt DateTime  @default(now())
  deletedAt   DateTime?

  invite     ReferralInvite @relation(fields: [inviteId], references: [id])
  friendUser User           @relation("ReferralConversions", fields: [friendUserId], references: [id])

  @@index([inviteId])
  @@index([friendUserId])
  @@map("referral_conversions")
}

model UserReferralStats {
  userId String @id

  totalInvitesSent Int @default(0)
  totalClicks      Int @default(0)
  totalConversions Int @default(0)

  totalCreditsEarned   Float @default(0)
  currentCreditBalance Float @default(0)

  badges Json @default("[]")

  currentStreak Int @default(0)
  longestStreak Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
  @@map("user_referral_stats")
}

model WorkoutBuddy {
  id String @id @default(cuid())

  userId  String
  buddyId String

  firstActivityId String
  connectedVia    String @default("referral")

  activitiesTogether Int      @default(1)
  firstWorkoutDate   DateTime @default(now())
  lastWorkoutDate    DateTime @default(now())

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  deletedAt DateTime?

  user          User     @relation("WorkoutBuddiesAsUser", fields: [userId], references: [id])
  buddy         User     @relation("WorkoutBuddiesAsBuddy", fields: [buddyId], references: [id])
  firstActivity Activity @relation(fields: [firstActivityId], references: [id])

  @@unique([userId, buddyId])
  @@index([userId])
  @@index([buddyId])
  @@map("workout_buddies")
}

model Notification {
  id        String           @id @default(cuid())
  userId    String
  type      NotificationType
  title     String
  content   String
  link      String?
  isRead    Boolean          @default(false)
  metadata  Json?
  createdAt DateTime         @default(now())
  updatedAt DateTime         @updatedAt

  user User @relation("UserNotifications", fields: [userId], references: [id])

  @@index([userId])
  @@index([isRead])
  @@index([createdAt])
  @@map("notifications")
}

model Mention {
  id                String   @id @default(cuid())
  messageId         String
  mentionedUserId   String
  mentionedByUserId String
  mentionText       String
  createdAt         DateTime @default(now())

  message       Message @relation(fields: [messageId], references: [id])
  mentionedUser User    @relation("MentionsReceived", fields: [mentionedUserId], references: [id])
  mentionedBy   User    @relation("MentionsSent", fields: [mentionedByUserId], references: [id])

  @@index([messageId])
  @@index([mentionedUserId])
  @@index([mentionedByUserId])
  @@map("mentions")
}

model NotificationPreference {
  id              String   @id @default(cuid())
  userId          String   @unique
  mentionEnabled  Boolean  @default(true)
  messageEnabled  Boolean  @default(true)
  activityEnabled Boolean  @default(true)
  emailEnabled    Boolean  @default(false)
  pushEnabled     Boolean  @default(false)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  user User @relation(fields: [userId], references: [id])

  @@map("notification_preferences")
}

// =====================================================
// HOST STATISTICS SYSTEM
// =====================================================

// Denormalized host stats table (fast reads)
model HostStats {
  id     String @id @default(cuid())
  hostId String @unique

  // Event counts
  totalEvents          Int @default(0)
  totalEventsThisMonth Int @default(0)
  totalEventsThisYear  Int @default(0)
  upcomingEvents       Int @default(0)
  completedEvents      Int @default(0)
  cancelledEvents      Int @default(0)

  // Attendee counts
  totalBookings                 Int @default(0)
  totalBookingsThisMonth        Int @default(0)
  totalUniqueAttendees          Int @default(0)
  totalUniqueAttendeesThisMonth Int @default(0)

  // Capacity & attendance
  totalSpotsOffered        Int     @default(0)
  totalSpotsFilled         Int     @default(0)
  averageAttendanceRate    Decimal @default(0) @db.Decimal(5, 2)
  averageAttendeesPerEvent Decimal @default(0) @db.Decimal(5, 2)

  // Repeat attendees
  repeatAttendees    Int     @default(0)
  repeatAttendeeRate Decimal @default(0) @db.Decimal(5, 2)

  // Revenue (for paid events)
  totalRevenue           Decimal @default(0) @db.Decimal(12, 2)
  totalRevenueThisMonth  Decimal @default(0) @db.Decimal(12, 2)
  totalRevenueThisYear   Decimal @default(0) @db.Decimal(12, 2)
  averageRevenuePerEvent Decimal @default(0) @db.Decimal(10, 2)

  // Ratings
  averageRating   Decimal @default(0) @db.Decimal(3, 2)
  totalReviews    Int     @default(0)
  fiveStarReviews Int     @default(0)

  // Engagement
  totalProfileViews     Int     @default(0)
  totalActivityViews    Int     @default(0)
  bookingConversionRate Decimal @default(0) @db.Decimal(5, 2)

  // Streaks & milestones
  currentStreakWeeks Int @default(0)
  longestStreakWeeks Int @default(0)

  // Timestamps
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt
  lastAggregatedAt DateTime?

  host User @relation("HostStats", fields: [hostId], references: [id], onDelete: Cascade)

  @@index([hostId])
  @@index([updatedAt])
  @@map("host_stats")
}

// Activity stats table (per-activity performance)
model ActivityStats {
  id         String @id @default(cuid())
  activityId String @unique
  hostId     String

  // Capacity
  totalSpots     Int     @default(0)
  spotsFilled    Int     @default(0)
  spotsRemaining Int     @default(0)
  fillRate       Decimal @default(0) @db.Decimal(5, 2)

  // Bookings
  totalBookings     Int @default(0)
  confirmedBookings Int @default(0)
  cancelledBookings Int @default(0)

  // Engagement
  viewCount     Int @default(0)
  uniqueViewers Int @default(0)
  shareCount    Int @default(0)
  saveCount     Int @default(0)

  // Conversion
  viewToBookingRate Decimal @default(0) @db.Decimal(5, 2)

  // Revenue
  totalRevenue Decimal @default(0) @db.Decimal(10, 2)

  // Ratings (post-event)
  averageRating Decimal @default(0) @db.Decimal(3, 2)
  reviewCount   Int     @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  activity Activity @relation("ActivityStats", fields: [activityId], references: [id], onDelete: Cascade)
  host     User     @relation("HostActivityStats", fields: [hostId], references: [id], onDelete: Cascade)

  @@index([activityId])
  @@index([hostId])
  @@map("activity_stats")
}

// Daily stats snapshot (for historical trends)
model HostStatsDaily {
  id     String   @id @default(cuid())
  hostId String
  date   DateTime @db.Date

  // Daily counts
  eventsHosted  Int @default(0)
  newBookings   Int @default(0)
  cancellations Int @default(0)
  newAttendees  Int @default(0)

  // Revenue
  revenue Decimal @default(0) @db.Decimal(10, 2)

  // Engagement
  profileViews  Int @default(0)
  activityViews Int @default(0)

  // Timestamps
  createdAt DateTime @default(now())

  host User @relation("HostStatsDaily", fields: [hostId], references: [id], onDelete: Cascade)

  @@unique([hostId, date])
  @@index([hostId, date])
  @@map("host_stats_daily")
}

// Monthly stats snapshot (for dashboards)
model HostStatsMonthly {
  id     String @id @default(cuid())
  hostId String
  year   Int
  month  Int

  // Monthly aggregates
  eventsHosted    Int @default(0)
  totalBookings   Int @default(0)
  uniqueAttendees Int @default(0)
  newAttendees    Int @default(0)
  repeatAttendees Int @default(0)

  // Capacity
  totalSpotsOffered Int     @default(0)
  totalSpotsFilled  Int     @default(0)
  averageFillRate   Decimal @default(0) @db.Decimal(5, 2)

  // Revenue
  totalRevenue           Decimal @default(0) @db.Decimal(10, 2)
  averageRevenuePerEvent Decimal @default(0) @db.Decimal(10, 2)

  // Ratings
  averageRating Decimal @default(0) @db.Decimal(3, 2)
  newReviews    Int     @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  host User @relation("HostStatsMonthly", fields: [hostId], references: [id], onDelete: Cascade)

  @@unique([hostId, year, month])
  @@index([hostId, year, month])
  @@map("host_stats_monthly")
}

// Attendee history (for repeat attendee tracking)
model AttendeeHistory {
  id         String @id @default(cuid())
  hostId     String
  attendeeId String

  // Attendance counts
  totalEventsAttended Int       @default(1)
  firstEventDate      DateTime?
  lastEventDate       DateTime?

  // Revenue from this attendee
  totalSpent Decimal @default(0) @db.Decimal(10, 2)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  host     User @relation("HostAttendeeHistory", fields: [hostId], references: [id], onDelete: Cascade)
  attendee User @relation("AttendeeHistory", fields: [attendeeId], references: [id], onDelete: Cascade)

  @@unique([hostId, attendeeId])
  @@index([hostId])
  @@index([attendeeId])
  @@map("attendee_history")
}

// Activity view tracking (for conversion stats)
model ActivityView {
  id         String  @id @default(cuid())
  activityId String
  viewerId   String?

  // View metadata
  source   String? // 'explore', 'search', 'direct', 'share'
  referrer String?

  // Device info
  deviceType String? // 'mobile', 'desktop', 'tablet'

  // Timestamps
  viewedAt DateTime @default(now())

  activity Activity @relation("ActivityViews", fields: [activityId], references: [id], onDelete: Cascade)
  viewer   User?    @relation("UserActivityViews", fields: [viewerId], references: [id], onDelete: SetNull)

  @@index([activityId])
  @@index([viewedAt])
  @@map("activity_views")
}

// Aggregation job tracking
model StatsAggregationJob {
  id      String @id @default(cuid())
  jobType String // 'host_stats', 'activity_stats', 'daily', 'monthly'
  status  String @default("pending") // 'pending', 'running', 'completed', 'failed'

  // Scope
  hostId String?

  // Progress
  startedAt        DateTime?
  completedAt      DateTime?
  recordsProcessed Int       @default(0)

  // Error tracking
  errorMessage String?
  retryCount   Int     @default(0)

  // Timestamps
  createdAt DateTime @default(now())

  @@index([status, createdAt])
  @@map("stats_aggregation_jobs")
}

// =====================================================
// USER PROFILE & COMMUNITY SYSTEM
// =====================================================

// User followers table (for follow functionality)
model UserFollower {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  follower  User @relation("UserFollowing", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("UserFollowers", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("user_followers")
}

// Profile views table (for analytics)
model ProfileView {
  id        String   @id @default(cuid())
  profileId String
  viewerId  String?
  viewedAt  DateTime @default(now())
  source    String? // 'activity', 'search', 'direct'

  profile User  @relation("ProfileViews", fields: [profileId], references: [id], onDelete: Cascade)
  viewer  User? @relation("ProfileViewers", fields: [viewerId], references: [id], onDelete: SetNull)

  @@index([profileId, viewedAt])
  @@index([viewerId])
  @@map("profile_views")
}

// User reviews table (for host reviews)
model UserReview {
  id         String   @id @default(cuid())
  reviewerId String
  revieweeId String
  activityId String?
  rating     Int // 1-5
  comment    String?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  @@unique([reviewerId, revieweeId, activityId])
  @@index([revieweeId])
  @@index([reviewerId])
  @@index([activityId])
  @@map("user_reviews")
}

// =====================================================
// INVITE-ONLY BETA SYSTEM
// =====================================================

enum BetaCodeType {
  SINGLE
  MULTI
  UNLIMITED
}

enum WaitlistStatus {
  WAITING
  INVITED
  JOINED
}

// Beta invite codes table
model BetaInviteCode {
  id       String       @id @default(cuid())
  code     String       @unique
  codeType BetaCodeType @default(SINGLE)

  // Usage limits
  maxUses     Int @default(1)
  currentUses Int @default(0)

  // Who created it
  createdByUserId String?
  createdByAdmin  Boolean @default(false)

  // Metadata
  label String? @db.VarChar(100)
  notes String?

  // Status
  isActive  Boolean   @default(true)
  expiresAt DateTime?

  // Timestamps
  createdAt   DateTime  @default(now())
  firstUsedAt DateTime?
  lastUsedAt  DateTime?

  // Relations
  createdByUser User?           @relation("BetaCodesCreated", fields: [createdByUserId], references: [id], onDelete: SetNull)
  accessLogs    BetaAccessLog[]

  @@index([code])
  @@index([isActive, currentUses, maxUses])
  @@index([createdByUserId])
  @@map("beta_invite_codes")
}

// Beta access log (who used which code)
model BetaAccessLog {
  id           String  @id @default(cuid())
  inviteCodeId String?
  codeUsed     String

  // Who used it
  userId String?
  email  String? @db.VarChar(255)

  // Access info
  ipAddress String? @db.VarChar(45)
  userAgent String?

  // Outcome
  accessGranted     Boolean @default(true)
  convertedToSignup Boolean @default(false)

  createdAt DateTime @default(now())

  // Relations
  inviteCode BetaInviteCode? @relation(fields: [inviteCodeId], references: [id], onDelete: SetNull)
  user       User?           @relation("BetaAccessLogs", fields: [userId], references: [id], onDelete: SetNull)

  @@index([inviteCodeId])
  @@index([userId])
  @@index([codeUsed])
  @@map("beta_access_log")
}

// Beta waitlist
model BetaWaitlist {
  id    String  @id @default(cuid())
  email String  @unique @db.VarChar(255)
  name  String? @db.VarChar(200)

  // Interest info
  interestedAs   String  @default("member") @db.VarChar(20)
  referralSource String? @db.VarChar(100)

  // Status
  status         WaitlistStatus @default(WAITING)
  inviteCodeSent String?        @db.VarChar(20)
  invitedAt      DateTime?

  // Priority (for sorting waitlist)
  priorityScore Int @default(0)

  createdAt DateTime @default(now())

  @@index([email])
  @@index([status, priorityScore])
  @@map("beta_waitlist")
}

// Beta settings (singleton table)
model BetaSettings {
  id               Int     @id @default(1)
  isBetaActive     Boolean @default(true)
  maxBetaUsers     Int     @default(500)
  currentBetaUsers Int     @default(0)

  // Invite settings
  invitesPerUser Int @default(3)

  // Display settings
  showSpotsRemaining   Boolean @default(true)
  showWaitlistPosition Boolean @default(true)

  updatedAt DateTime @updatedAt

  @@map("beta_settings")
}

// =====================================================
// ACTIVITY WAITLIST & URGENCY SYSTEM
// =====================================================

enum ActivityWaitlistStatus {
  WAITING
  NOTIFIED
  BOOKED
  EXPIRED
  CANCELLED
}

enum WaitlistNotificationType {
  SPOT_AVAILABLE
  REMINDER
  EXPIRED
  POSITION_UPDATE
  CONFIRMATION
}

// Activity waitlist entries
model ActivityWaitlist {
  id String @id @default(cuid())

  // Activity reference
  activityId String

  // Who's waiting (user or email for non-logged-in)
  userId String?
  email  String? @db.VarChar(255)
  name   String? @db.VarChar(200)

  // Position and status
  position Int
  status   ActivityWaitlistStatus @default(WAITING)

  // Notification tracking
  notifiedAt            DateTime?
  notificationExpiresAt DateTime? // 24-hour window to book
  reminderSent          Boolean   @default(false)

  // Outcome
  convertedToBooking Boolean @default(false)
  userActivityId     String? @unique // Reference to booking if converted

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  activity      Activity               @relation("ActivityWaitlist", fields: [activityId], references: [id], onDelete: Cascade)
  user          User?                  @relation("UserWaitlistEntries", fields: [userId], references: [id], onDelete: Cascade)
  userActivity  UserActivity?          @relation("WaitlistBooking", fields: [userActivityId], references: [id], onDelete: SetNull)
  notifications WaitlistNotification[]

  // Ensure one entry per user per activity
  @@unique([activityId, userId])
  @@unique([activityId, email])
  @@index([activityId, status, position])
  @@index([userId])
  @@index([status, notifiedAt])
  @@index([notificationExpiresAt])
  @@map("activity_waitlists")
}

// Waitlist notification log
model WaitlistNotification {
  id String @id @default(cuid())

  waitlistEntryId String
  activityId      String
  userId          String?
  email           String? @db.VarChar(255)

  // Notification details
  notificationType WaitlistNotificationType
  channel          String                   @default("email") @db.VarChar(20) // 'email', 'push', 'sms'

  // Status
  sentAt    DateTime  @default(now())
  openedAt  DateTime?
  clickedAt DateTime?

  // Metadata
  metadata Json?

  // Relations
  waitlistEntry ActivityWaitlist @relation(fields: [waitlistEntryId], references: [id], onDelete: Cascade)

  @@index([waitlistEntryId])
  @@index([activityId])
  @@index([userId])
  @@map("waitlist_notifications")
}

// Activity urgency settings (extend Activity model)
model ActivityUrgencySettings {
  id         String @id @default(cuid())
  activityId String @unique

  // Urgency display settings
  showSpotsRemaining Boolean @default(true)
  urgencyThreshold   Int     @default(5) // Show urgency when <= X spots

  // Waitlist settings
  waitlistEnabled         Boolean @default(true)
  waitlistLimit           Int     @default(50) // Max waitlist size
  notificationWindowHours Int     @default(24) // Hours to book after notification

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  activity Activity @relation("ActivityUrgencySettings", fields: [activityId], references: [id], onDelete: Cascade)

  @@index([activityId])
  @@map("activity_urgency_settings")
}

// =====================================================
// AUTOMATED REMINDER SYSTEM
// =====================================================

enum ReminderType {
  ONE_WEEK // 7 days before (optional)
  ONE_DAY // 24 hours before
  TWO_HOURS // 2 hours before
}

enum ReminderStatus {
  PENDING
  SENT
  FAILED
  CANCELLED
  SKIPPED
}

enum ReminderChannel {
  EMAIL
  PUSH
  SMS
  IN_APP
}

// Scheduled reminders for bookings
model ScheduledReminder {
  id String @id @default(cuid())

  // What this reminder is for
  userActivityId String
  activityId     String
  userId         String

  // Reminder configuration
  reminderType ReminderType
  channel      ReminderChannel @default(EMAIL)
  scheduledFor DateTime // When to send

  // Status tracking
  status       ReminderStatus @default(PENDING)
  sentAt       DateTime?
  openedAt     DateTime?
  clickedAt    DateTime?
  errorMessage String?

  // Retry tracking
  retryCount  Int       @default(0)
  lastRetryAt DateTime?

  // Message customization (optional host overrides)
  customSubject String? @db.VarChar(200)
  customMessage String? @db.Text

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userActivityId, reminderType, channel])
  @@index([status, scheduledFor])
  @@index([userId])
  @@index([activityId])
  @@map("scheduled_reminders")
}

// Reminder delivery log (for analytics)
model ReminderDeliveryLog {
  id String @id @default(cuid())

  reminderId     String?
  userActivityId String
  activityId     String
  userId         String

  // Delivery details
  reminderType ReminderType
  channel      ReminderChannel

  // Status
  deliveredAt DateTime  @default(now())
  openedAt    DateTime?
  clickedAt   DateTime?

  // Email-specific tracking
  emailMessageId String? @db.VarChar(255)
  emailProvider  String? @db.VarChar(50) // 'resend', 'sendgrid', etc.

  // Push-specific tracking
  pushEndpoint String?

  // Metadata
  metadata Json?

  @@index([reminderId])
  @@index([userActivityId])
  @@index([activityId])
  @@index([userId])
  @@index([deliveredAt])
  @@map("reminder_delivery_logs")
}

// Host reminder settings (customization per activity)
model HostReminderSettings {
  id         String @id @default(cuid())
  activityId String @unique
  hostId     String

  // Enable/disable reminders
  enableOneWeekReminder Boolean @default(false)
  enableOneDayReminder  Boolean @default(true)
  enableTwoHourReminder Boolean @default(true)

  // Custom messages (optional)
  oneDaySubject  String? @db.VarChar(200)
  oneDayMessage  String? @db.Text
  twoHourSubject String? @db.VarChar(200)
  twoHourMessage String? @db.Text
  oneWeekSubject String? @db.VarChar(200)
  oneWeekMessage String? @db.Text

  // Additional info to include
  includeMapLink      Boolean @default(true)
  includeCalendarLink Boolean @default(true)
  includeHostContact  Boolean @default(false)
  customInstructions  String? @db.Text // "Bring a towel", "Park in lot B", etc.

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([activityId])
  @@index([hostId])
  @@map("host_reminder_settings")
}

// User push notification subscriptions
model PushSubscription {
  id     String @id @default(cuid())
  userId String

  // Web Push subscription details
  endpoint String @db.Text
  p256dh   String @db.VarChar(255)
  auth     String @db.VarChar(255)

  // Device info
  userAgent  String? @db.VarChar(500)
  deviceType String? @db.VarChar(50) // 'desktop', 'mobile', 'tablet'

  // Status
  isActive     Boolean  @default(true)
  lastUsedAt   DateTime @default(now())
  failureCount Int      @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userId, endpoint])
  @@index([userId, isActive])
  @@map("push_subscriptions")
}

// Extended notification preferences for reminders
model ReminderPreferences {
  id     String @id @default(cuid())
  userId String @unique

  // Reminder type preferences
  enableOneWeekReminder Boolean @default(false)
  enableOneDayReminder  Boolean @default(true)
  enableTwoHourReminder Boolean @default(true)

  // Channel preferences
  emailReminders Boolean @default(true)
  pushReminders  Boolean @default(true)
  smsReminders   Boolean @default(false)

  // Quiet hours (don't send during these times)
  quietHoursStart Int? // Hour of day (0-23)
  quietHoursEnd   Int? // Hour of day (0-23)
  timezone        String @default("Asia/Singapore") @db.VarChar(50)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("reminder_preferences")
}

// =====================================================
// REVIEWS & RATINGS SYSTEM
// =====================================================

enum ReviewStatus {
  PENDING // Just submitted, awaiting moderation (if enabled)
  PUBLISHED // Visible to everyone
  HIDDEN // Hidden by admin/moderation
  DELETED // Soft deleted
}

enum ReviewPromptStatus {
  PENDING // Scheduled but not sent yet
  SENT // Email sent
  COMPLETED // Review submitted
  EXPIRED // Past reminder period
  SKIPPED // User opted out
}

// Activity reviews from attendees
model Review {
  id String @id @default(cuid())

  // What's being reviewed
  activityId     String
  userActivityId String @unique // Ensures one review per booking

  // Who's reviewing
  reviewerId String

  // Who's being reviewed (the host)
  hostId String

  // Review content
  rating  Int // 1-5 stars
  title   String? @db.VarChar(200)
  content String? @db.Text

  // Photo attachments (up to 5 URLs)
  photos String[] @default([])

  // Status
  status     ReviewStatus @default(PUBLISHED)
  isVerified Boolean      @default(true) // Verified attendee

  // Engagement
  helpfulCount Int @default(0)

  // Edit tracking
  editedAt  DateTime?
  editCount Int       @default(0)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  activity     Activity            @relation("ActivityReviews", fields: [activityId], references: [id], onDelete: Cascade)
  userActivity UserActivity        @relation("BookingReview", fields: [userActivityId], references: [id], onDelete: Cascade)
  reviewer     User                @relation("ReviewsWritten", fields: [reviewerId], references: [id], onDelete: Cascade)
  host         User                @relation("ReviewsReceived", fields: [hostId], references: [id], onDelete: Cascade)
  hostResponse ReviewResponse?
  helpfulVotes ReviewHelpfulVote[]

  @@index([activityId, status, createdAt])
  @@index([hostId, status, createdAt])
  @@index([reviewerId, status])
  @@index([status, helpfulCount])
  @@index([rating])
  @@map("reviews")
}

// Host responses to reviews
model ReviewResponse {
  id       String @id @default(cuid())
  reviewId String @unique
  hostId   String
  content  String @db.Text

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt
  editedAt  DateTime?

  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@index([hostId])
  @@map("review_responses")
}

// Track helpful votes on reviews
model ReviewHelpfulVote {
  id        String   @id @default(cuid())
  reviewId  String
  userId    String
  createdAt DateTime @default(now())

  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@unique([reviewId, userId])
  @@index([reviewId])
  @@index([userId])
  @@map("review_helpful_votes")
}

// Scheduled review prompts
model ReviewPrompt {
  id             String @id @default(cuid())
  userActivityId String
  activityId     String
  userId         String

  // Scheduling
  scheduledFor DateTime // When to send first prompt
  reminderAt   DateTime? // When to send reminder

  // Status tracking
  status         ReviewPromptStatus @default(PENDING)
  sentAt         DateTime?
  reminderSentAt DateTime?
  completedAt    DateTime?

  // Email tracking
  emailMessageId String?   @db.VarChar(255)
  openedAt       DateTime?
  clickedAt      DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([userActivityId])
  @@index([status, scheduledFor])
  @@index([status, reminderAt])
  @@index([userId, status])
  @@index([activityId])
  @@map("review_prompts")
}

// Denormalized activity rating summary (for fast queries)
model ActivityRatingSummary {
  id         String @id @default(cuid())
  activityId String @unique

  // Aggregate stats
  averageRating Decimal @default(0) @db.Decimal(3, 2)
  totalReviews  Int     @default(0)

  // Rating distribution
  fiveStarCount  Int @default(0)
  fourStarCount  Int @default(0)
  threeStarCount Int @default(0)
  twoStarCount   Int @default(0)
  oneStarCount   Int @default(0)

  // Last updated
  lastReviewAt DateTime?
  updatedAt    DateTime  @updatedAt

  activity Activity @relation("ActivityRatingSummary", fields: [activityId], references: [id], onDelete: Cascade)

  @@index([averageRating])
  @@map("activity_rating_summaries")
}

// Denormalized host rating summary
model HostRatingSummary {
  id     String @id @default(cuid())
  hostId String @unique

  // Aggregate stats
  averageRating Decimal @default(0) @db.Decimal(3, 2)
  totalReviews  Int     @default(0)

  // Rating distribution
  fiveStarCount  Int @default(0)
  fourStarCount  Int @default(0)
  threeStarCount Int @default(0)
  twoStarCount   Int @default(0)
  oneStarCount   Int @default(0)

  // Response stats
  totalResponses Int     @default(0)
  responseRate   Decimal @default(0) @db.Decimal(5, 2)

  // Last updated
  lastReviewAt DateTime?
  updatedAt    DateTime  @updatedAt

  host User @relation("HostRatingSummary", fields: [hostId], references: [id], onDelete: Cascade)

  @@index([averageRating])
  @@map("host_rating_summaries")
}

// =====================================================
// EVENT SUBMISSIONS (Public form submissions)
// =====================================================

enum EventSubmissionStatus {
  PENDING
  APPROVED
  REJECTED
  CANCELLED
}

// Fee handling options for paid events
enum FeeHandling {
  PASS // Attendee pays fees on top of ticket price
  ABSORB // Host absorbs fees (deducted from payout)
}

// Refund policy options
enum RefundPolicy {
  FULL_ANYTIME // Full refund anytime before event
  FULL_24H // Full refund up to 24 hours before
  NONE // No refunds
}

model EventSubmission {
  id   String  @id @default(cuid())
  slug String? @unique @db.VarChar(250) // URL-friendly slug (e.g., "coffee-run-dec-27")

  // Event details
  eventName     String    @db.VarChar(200)
  category      String    @db.VarChar(50)
  day           String    @db.VarChar(50) // Legacy field - keeping for backward compatibility
  eventDate     DateTime? // Next occurrence date (e.g., "2024-01-15")
  time          String    @db.VarChar(50)
  recurring     Boolean   @default(true) // If true, event repeats weekly on this day
  location      String    @db.VarChar(300)
  latitude      Float?
  longitude     Float?
  placeId       String?   @db.VarChar(100)
  description   String?   @db.Text
  imageUrl      String?   @db.VarChar(500) // Event image uploaded via UploadThing
  communityLink String?   @db.VarChar(500) // WhatsApp/Telegram/Discord group link

  // Organizer details
  organizerName      String @db.VarChar(200)
  organizerInstagram String @db.VarChar(500)
  contactEmail       String @db.VarChar(255)

  // Status
  status          EventSubmissionStatus @default(PENDING)
  reviewedAt      DateTime?
  reviewedBy      String? // Admin user ID who reviewed
  rejectionReason String?               @db.Text
  moderationNotes String?               @db.Text // AI moderation notes/logs

  // Capacity
  isFull Boolean @default(false) // Mark event as full

  // Pricing
  isFree   Boolean @default(true)
  price    Int? // Amount in cents (e.g., 1500 = $15.00)
  currency String? @default("SGD") @db.VarChar(3)

  // PayNow details (for manual verification)
  paynowEnabled Boolean @default(false)
  paynowQrCode  String? @db.VarChar(500) // URL to uploaded QR image
  paynowNumber  String? @db.VarChar(50) // UEN or phone number
  paynowName    String? @db.VarChar(200) // Name that appears on PayNow

  // Stripe (for automatic payment)
  stripeEnabled Boolean @default(false)

  // Paid event capacity & settings
  maxTickets   Int? // Max capacity (null = unlimited)
  ticketsSold  Int           @default(0) // Current sold count
  feeHandling  FeeHandling? // Who pays fees: PASS or ABSORB
  salesEndDate DateTime? // When ticket sales close
  refundPolicy RefundPolicy? // Refund policy

  // Cancellation (by host)
  cancelledAt        DateTime?
  cancelledBy        String?   @db.VarChar(255) // Host Instagram who cancelled
  cancellationReason String?   @db.Text

  // User account link (for authenticated hosts)
  submittedByUserId String? // Clerk user ID who submitted
  submittedByUser   User?   @relation("UserEventSubmissions", fields: [submittedByUserId], references: [id])

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, createdAt])
  @@index([contactEmail])
  @@index([slug])
  @@index([submittedByUserId])
  @@map("event_submissions")
}

// =====================================================
// EVENT ATTENDANCE & NEWSLETTER SYSTEM
// =====================================================

// Track attendance from "I'm Going" button on public events
model EventAttendance {
  id             String   @id @default(cuid())
  eventId        String // References the event (from events.ts data file)
  eventName      String   @db.VarChar(200)
  email          String   @db.VarChar(255)
  name           String?  @db.VarChar(200)
  subscribe      Boolean  @default(true) // Opt-in to newsletter
  timestamp      DateTime @default(now())
  confirmed      Boolean  @default(true)
  mealPreference String?  @db.VarChar(50) // Optional meal choice: 'vegetarian', 'chicken', 'beef'

  // Payment fields
  paymentStatus    String?   @default("free") @db.VarChar(20) // 'free', 'pending', 'paid', 'failed', 'refunded'
  paymentMethod    String?   @db.VarChar(20) // 'stripe', 'paynow'
  paymentAmount    Int? // Amount in cents
  paymentReference String?   @db.VarChar(100) // Transaction ref for PayNow
  stripePaymentId  String?   @db.VarChar(100) // Stripe payment intent ID
  paidAt           DateTime?
  verifiedBy       String?   @db.VarChar(255) // Host email who verified
  verifiedAt       DateTime?

  // Attendance tracking (did they actually show up?)
  actuallyAttended Boolean? // null=unmarked, true=showed up, false=no-show
  markedAttendedAt DateTime?
  markedAttendedBy String?   @db.VarChar(255) // Host email who marked

  // One-time waiver acceptance (per user, covers all future events)
  waiverAccepted   Boolean   @default(false)
  waiverVersion    String?   @db.VarChar(10) // e.g., "1.0"
  waiverAcceptedAt DateTime?
  waiverAcceptedIp String?   @db.VarChar(45) // IPv4 or IPv6

  // QR Code check-in
  checkInCode     String?   @unique @db.VarChar(20) // Unique code for QR
  checkedInAt     DateTime? // When checked in via QR
  checkedInMethod String?   @db.VarChar(20) // 'qr' | 'manual'

  @@unique([email, eventId])
  @@index([eventId])
  @@index([email])
  @@index([timestamp])
  @@index([paymentStatus])
  @@map("event_attendances")
}

// Event reminders (24h before event)
model EventReminder {
  id           String    @id @default(cuid())
  attendanceId String    @unique // References EventAttendance.id
  eventId      String // References EventSubmission.id
  scheduledFor DateTime // When to send (24h before event)
  status       String    @default("PENDING") @db.VarChar(20) // PENDING, SENT, SKIPPED, FAILED
  sentAt       DateTime?
  errorMessage String?   @db.Text
  createdAt    DateTime  @default(now())

  @@index([status, scheduledFor])
  @@index([eventId])
  @@map("event_reminders")
}

// Event reviews (attendees can rate events after attending)
model EventReview {
  id            String  @id @default(cuid())
  eventId       String // References EventSubmission.id
  attendanceId  String  @unique // One review per attendance
  reviewerEmail String  @db.VarChar(255)
  reviewerName  String? @db.VarChar(200)
  hostInstagram String  @db.VarChar(500) // For host rating aggregation

  // Rating & content
  rating  Int // 1-5 stars
  title   String?  @db.VarChar(200)
  content String?  @db.Text
  photos  String[] // Array of photo URLs

  // Interaction metrics
  helpfulCount Int @default(0)

  // Host response
  hostResponse    String?   @db.Text
  hostRespondedAt DateTime?

  // Status
  isPublished Boolean @default(true)
  isFlagged   Boolean @default(false)
  flagReason  String? @db.VarChar(200)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([eventId])
  @@index([hostInstagram])
  @@index([rating])
  @@index([createdAt])
  @@map("event_reviews")
}

// Post-event follow-up (2h after event ends)
model PostEventFollowUp {
  id           String    @id @default(cuid())
  attendanceId String    @unique // References EventAttendance.id
  eventId      String // References EventSubmission.id
  scheduledFor DateTime // When to send (2h after event)
  status       String    @default("PENDING") @db.VarChar(20) // PENDING, SENT, SKIPPED, FAILED
  sentAt       DateTime?
  errorMessage String?   @db.Text
  createdAt    DateTime  @default(now())

  @@index([status, scheduledFor])
  @@index([eventId])
  @@map("post_event_followups")
}

// Host notes about attendees (email-based, no user account required)
model HostAttendeeNotes {
  id            String   @id @default(cuid())
  hostInstagram String   @db.VarChar(500) // Host identifier (Instagram handle)
  attendeeEmail String   @db.VarChar(255) // Attendee email
  notes         String?  @db.Text // Host's notes about this person
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  @@unique([hostInstagram, attendeeEmail])
  @@index([hostInstagram])
  @@map("host_attendee_notes")
}

// Newsletter subscribers from various sources
model NewsletterSubscriber {
  id             String    @id @default(cuid())
  email          String    @unique @db.VarChar(255)
  name           String?   @db.VarChar(200)
  subscribedAt   DateTime  @default(now())
  source         String    @default("event_attendance") @db.VarChar(50) // 'event_attendance', 'waitlist', 'footer', etc.
  isActive       Boolean   @default(true)
  unsubscribedAt DateTime?

  @@index([email])
  @@index([source])
  @@index([subscribedAt])
  @@map("newsletter_subscribers")
}

// Magic link tokens for accessing my-events page
model MagicLinkToken {
  id        String    @id @default(cuid())
  email     String    @db.VarChar(255)
  token     String    @unique @db.VarChar(64)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([email])
  @@index([token])
  @@index([expiresAt])
  @@map("magic_link_tokens")
}

// Chat messages for public events (EventDetailSheet)
model EventChatMessage {
  id          String   @id @default(cuid())
  eventId     String   @db.VarChar(100) // References event from events.json or submission-{id}
  content     String   @db.Text
  senderName  String   @db.VarChar(200)
  senderEmail String   @db.VarChar(255)
  createdAt   DateTime @default(now())

  @@index([eventId])
  @@index([createdAt])
  @@map("event_chat_messages")
}

// =====================================================
// HOST APPLICATION WAITLIST SYSTEM
// =====================================================

enum HostApplicationStatus {
  PENDING
  APPROVED
  REJECTED
}

// Host applications from waitlist/intake form
model HostApplication {
  id String @id @default(cuid())

  // Organizer details
  organizerName   String @db.VarChar(200)
  instagramHandle String @db.VarChar(100)
  email           String @db.VarChar(255)

  // Event details
  eventName   String  @db.VarChar(200)
  eventType   String  @db.VarChar(50) // Run Club, Yoga, HIIT, Cold Plunge, Bootcamp, Other
  eventDay    String  @db.VarChar(100) // e.g., "Saturdays" or "Every Tuesday"
  eventTime   String  @db.VarChar(50)
  location    String  @db.VarChar(300)
  description String? @db.Text

  // Status
  status          HostApplicationStatus @default(PENDING)
  reviewedAt      DateTime?
  reviewedBy      String?
  rejectionReason String?               @db.Text
  notes           String?               @db.Text // Internal admin notes

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status, createdAt])
  @@index([email])
  @@index([instagramHandle])
  @@map("host_applications")
}

// =====================================================
// ORGANIZER & DIRECT MESSAGING SYSTEM
// =====================================================

// Verified organizers (linked by Instagram handle)
model Organizer {
  id              String   @id @default(cuid())
  email           String   @unique @db.VarChar(255)
  instagramHandle String   @unique @db.VarChar(100)
  name            String?  @db.VarChar(200)
  isVerified      Boolean  @default(true) // Auto-verified in MVP
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  conversations EventDirectConversation[]

  @@index([instagramHandle])
  @@index([email])
  @@map("organizers")
}

// Magic link for organizer login
model OrganizerMagicLink {
  id        String    @id @default(cuid())
  email     String    @db.VarChar(255)
  token     String    @unique @db.VarChar(64)
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())

  @@index([token])
  @@map("organizer_magic_links")
}

// 1:1 conversation between organizer and attendee
model EventDirectConversation {
  id            String    @id @default(cuid())
  eventId       String    @db.VarChar(100)
  organizerId   String
  attendeeEmail String    @db.VarChar(255)
  attendeeName  String?   @db.VarChar(200)
  lastMessageAt DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  organizer Organizer            @relation(fields: [organizerId], references: [id], onDelete: Cascade)
  messages  EventDirectMessage[]

  @@unique([eventId, organizerId, attendeeEmail])
  @@index([eventId])
  @@index([organizerId])
  @@index([attendeeEmail])
  @@map("event_direct_conversations")
}

// Individual messages in 1:1 conversation
model EventDirectMessage {
  id             String   @id @default(cuid())
  conversationId String
  senderType     String   @db.VarChar(20) // 'organizer' or 'attendee'
  senderEmail    String   @db.VarChar(255)
  senderName     String   @db.VarChar(200)
  content        String   @db.Text
  createdAt      DateTime @default(now())

  conversation EventDirectConversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)

  @@index([conversationId])
  @@index([createdAt])
  @@map("event_direct_messages")
}

// =====================================================
// COMPLETION CARDS & SHARING SYSTEM
// =====================================================

enum CompletionCardStatus {
  DRAFT
  GENERATED
  SHARED
}

enum CompletionCardTemplate {
  CLASSIC
  MINIMAL
  BOLD
  GRADIENT
  DARK
  ENERGY
}

// Shareable completion cards for social media
model CompletionCard {
  id String @id @default(cuid())

  // References
  userId         String
  userActivityId String @unique
  activityId     String
  hostId         String

  // User's uploaded photo
  photoUrl    String @db.VarChar(500)
  photoWidth  Int?
  photoHeight Int?

  // Card customization
  template     CompletionCardTemplate @default(CLASSIC)
  caption      String?                @db.Text
  showHost     Boolean                @default(true)
  showDate     Boolean                @default(true)
  showDuration Boolean                @default(true)
  showStreak   Boolean                @default(false)

  // Generated card image
  cardUrl         String?   @db.VarChar(500)
  cardGeneratedAt DateTime?

  // Activity snapshot (in case activity is deleted)
  activityTitle   String   @db.VarChar(200)
  activityImage   String?  @db.VarChar(500)
  hostName        String   @db.VarChar(100)
  hostAvatar      String?  @db.VarChar(500)
  completedAt     DateTime
  durationMinutes Int?

  // Sharing stats
  downloadedCount Int      @default(0)
  sharedCount     Int      @default(0)
  sharePlatforms  String[] @default([])

  // QR code and link
  qrCodeUrl    String? @db.VarChar(500)
  activityLink String? @db.VarChar(500)

  // Status
  status CompletionCardStatus @default(DRAFT)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user         User         @relation("UserCompletionCards", fields: [userId], references: [id], onDelete: Cascade)
  userActivity UserActivity @relation("BookingCompletionCard", fields: [userActivityId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt])
  @@index([userActivityId])
  @@index([hostId])
  @@index([status])
  @@map("completion_cards")
}

// User streak tracking (for showing on completion cards)
model UserStreak {
  id     String  @id @default(cuid())
  userId String
  hostId String? // NULL = platform-wide streak, set = per-host streak

  // Streak type
  streakType String @default("weekly") @db.VarChar(30) // 'weekly', 'daily', 'monthly'

  // Streak counts
  currentStreak  Int       @default(0)
  longestStreak  Int       @default(0)
  lastActivityAt DateTime?

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  user User @relation("UserStreaks", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, hostId, streakType])
  @@index([userId, hostId])
  @@index([currentStreak])
  @@map("user_streaks")
}

// =====================================================
// PUBLIC EVENT WAITLIST SYSTEM
// =====================================================

enum EventWaitlistStatus {
  WAITING
  NOTIFIED
  BOOKED
  EXPIRED
}

// Waitlist for when events are full
model EventWaitlist {
  id      String  @id @default(cuid())
  eventId String // References EventSubmission.id
  email   String  @db.VarChar(255)
  name    String? @db.VarChar(200)

  // Position and status
  position Int
  status   EventWaitlistStatus @default(WAITING)

  // Notification tracking
  notifiedAt          DateTime?
  notificationExpires DateTime? // 24-hour window to book

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@unique([eventId, email])
  @@index([eventId, status, position])
  @@index([status, notifiedAt])
  @@map("event_waitlists")
}

// =====================================================
// PAID EVENTS & STRIPE CONNECT SYSTEM
// =====================================================

enum TransactionStatus {
  PENDING // Payment initiated
  SUCCEEDED // Payment completed
  FAILED // Payment failed
  REFUNDED // Full refund processed
  PARTIAL_REFUND // Partial refund processed
}

enum SubscriptionTier {
  FREE // Default tier (5% platform fee)
  PREMIUM // Premium tier (2% platform fee)
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  PAST_DUE
  EXPIRED
}

// Stripe Connect accounts for hosts
model HostStripeAccount {
  id                String @id @default(cuid())
  eventSubmissionId String @unique // Links to the event/host

  // Stripe Connect account info
  stripeConnectAccountId   String  @unique @db.VarChar(100) // e.g., "acct_1234..."
  stripeOnboardingComplete Boolean @default(false)
  payoutsEnabled           Boolean @default(false)
  chargesEnabled           Boolean @default(false)

  // Account details (cached from Stripe)
  email        String? @db.VarChar(255)
  businessName String? @db.VarChar(200)
  country      String? @db.VarChar(2) // ISO country code

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  transactions EventTransaction[]

  @@index([stripeConnectAccountId])
  @@index([eventSubmissionId])
  @@map("host_stripe_accounts")
}

// Transaction records for every ticket purchase
model EventTransaction {
  id                String @id @default(cuid())
  eventSubmissionId String // Which event this is for
  attendanceId      String // Links to EventAttendance record

  // Stripe payment info
  stripePaymentIntentId String? @unique @db.VarChar(100)
  stripeChargeId        String? @db.VarChar(100)

  // Financial breakdown (all in cents)
  ticketPrice     Int // Base ticket price
  platformFee     Int // SweatBuddies fee (5% or 2%)
  stripeFee       Int // Stripe processing fee
  netPayoutToHost Int // What host receives
  currency        String @default("SGD") @db.VarChar(3)

  // Fee handling
  feeHandling  FeeHandling // PASS or ABSORB
  totalCharged Int // Total charged to attendee

  // Status tracking
  status TransactionStatus @default(PENDING)

  // Refund tracking
  refundAmount Int? // Amount refunded (if any)
  refundedAt   DateTime?
  refundReason String?   @db.VarChar(500)

  // Host account reference
  hostStripeAccountId String?

  // Timestamps
  createdAt DateTime  @default(now())
  paidOutAt DateTime? // When host received payout

  // Relations
  hostStripeAccount HostStripeAccount? @relation(fields: [hostStripeAccountId], references: [id], onDelete: SetNull)

  @@index([eventSubmissionId])
  @@index([attendanceId])
  @@index([stripePaymentIntentId])
  @@index([status])
  @@index([createdAt])
  @@map("event_transactions")
}

// Host subscription for Premium tier
model HostSubscription {
  id             String @id @default(cuid())
  organizerEmail String @unique @db.VarChar(255) // Host's email

  // Subscription details
  tier   SubscriptionTier   @default(FREE)
  status SubscriptionStatus @default(ACTIVE)

  // Stripe subscription info (for Premium tier)
  stripeSubscriptionId String? @unique @db.VarChar(100)
  stripeCustomerId     String? @db.VarChar(100)

  // Billing period
  startedAt          DateTime  @default(now())
  currentPeriodStart DateTime?
  currentPeriodEnd   DateTime?
  endsAt             DateTime? // When subscription ends (if cancelled)

  // Cancellation info
  cancelledAt        DateTime?
  cancellationReason String?   @db.VarChar(500)

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([organizerEmail])
  @@index([tier, status])
  @@index([stripeSubscriptionId])
  @@map("host_subscriptions")
}

// =====================================================
// WAVE MODE  ACTIVITY-CENTERED CREW MATCHING
// =====================================================

enum WaveActivityType {
  // Cardio & Endurance
  RUN
  WALK
  CYCLE
  SWIM
  HIKE
  ROWING
  SURFING
  SPINNING

  // Strength & Conditioning
  GYM
  CROSSFIT
  HYROX
  STRETCHING
  PILATES

  // Racquet Sports
  TENNIS
  PICKLEBALL
  BADMINTON
  SQUASH

  // Team Sports
  BASKETBALL
  FOOTBALL
  VOLLEYBALL
  FRISBEE

  // Combat & Martial Arts
  BOXING
  MARTIAL_ARTS

  // Other Sports
  CLIMB
  GOLF
  SKATEBOARD
  DANCE

  // Wellness & Recovery
  YOGA
  MEDITATION
  BREATHWORK
  ICE_BATH
  SAUNA

  // Self-Improvement
  BOOK_CLUB
  NUTRITION

  // Flexible
  ANYTHING
}

model WaveActivity {
  id            String           @id @default(cuid())
  creatorId     String
  activityType  WaveActivityType
  area          String           @db.VarChar(200)
  locationName  String?          @db.VarChar(300)
  latitude      Float?
  longitude     Float?
  thought       String?          @db.VarChar(140)
  scheduledFor  DateTime?
  waveThreshold Int              @default(3)
  isUnlocked    Boolean          @default(false)
  startedAt     DateTime         @default(now())
  expiresAt     DateTime
  chatId        String?          @unique

  creator      User              @relation("WaveActivitiesCreated", fields: [creatorId], references: [id], onDelete: Cascade)
  participants WaveParticipant[]
  chat         CrewChat?         @relation(fields: [chatId], references: [id], onDelete: SetNull)

  @@index([creatorId])
  @@index([activityType])
  @@index([expiresAt])
  @@index([expiresAt, activityType])
  @@index([isUnlocked])
  @@map("wave_activities")
}

model WaveParticipant {
  id             String   @id @default(cuid())
  waveActivityId String
  userId         String
  wavedAt        DateTime @default(now())

  waveActivity WaveActivity @relation(fields: [waveActivityId], references: [id], onDelete: Cascade)
  user         User         @relation("WaveParticipations", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([waveActivityId, userId])
  @@index([waveActivityId])
  @@index([userId])
  @@map("wave_participants")
}

model CrewChat {
  id            String           @id @default(cuid())
  activityType  WaveActivityType
  area          String           @db.VarChar(200)
  createdAt     DateTime         @default(now())
  lastMessageAt DateTime?

  waveActivity WaveActivity?
  members      CrewChatMember[]
  messages     CrewMessage[]

  @@index([activityType])
  @@map("crew_chats")
}

model CrewChatMember {
  id       String   @id @default(cuid())
  chatId   String
  userId   String
  joinedAt DateTime @default(now())

  chat CrewChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  user User     @relation("CrewChatMemberships", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([chatId, userId])
  @@index([chatId])
  @@index([userId])
  @@map("crew_chat_members")
}

model CrewMessage {
  id        String   @id @default(cuid())
  chatId    String
  senderId  String
  content   String   @db.Text
  createdAt DateTime @default(now())

  chat   CrewChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender User     @relation("CrewMessagesSent", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatId, createdAt])
  @@index([senderId])
  @@map("crew_messages")
}

// =====================================================
// TRUST & SAFETY SYSTEM
// =====================================================

enum ReportReason {
  HARASSMENT
  SPAM
  INAPPROPRIATE_CONTENT
  FAKE_PROFILE
  OTHER
}

enum ReportStatus {
  PENDING
  REVIEWED
  ACTIONED
  DISMISSED
}

enum ModerationAction {
  WARNING
  SUSPENSION
  BAN
  DISMISS
}

enum UserAccountStatus {
  ACTIVE
  WARNED
  SUSPENDED
  BANNED
}

// User reports for trust & safety
model UserReport {
  id             String       @id @default(cuid())
  reporterId     String
  reportedUserId String
  reason         ReportReason
  details        String?      @db.Text
  status         ReportStatus @default(PENDING)

  // Resolution
  resolvedAt      DateTime?
  resolvedBy      String? // Admin user ID
  resolutionNotes String?           @db.Text
  actionTaken     ModerationAction?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  reporter     User @relation("ReportsMade", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedUser User @relation("ReportsReceived", fields: [reportedUserId], references: [id], onDelete: Cascade)

  @@index([reporterId])
  @@index([reportedUserId])
  @@index([status, createdAt])
  @@map("user_reports")
}

// User blocks for hiding content bidirectionally
model UserBlock {
  id            String   @id @default(cuid())
  blockerId     String
  blockedUserId String
  createdAt     DateTime @default(now())

  blocker     User @relation("BlocksMade", fields: [blockerId], references: [id], onDelete: Cascade)
  blockedUser User @relation("BlocksReceived", fields: [blockedUserId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedUserId])
  @@index([blockerId])
  @@index([blockedUserId])
  @@map("user_blocks")
}

// Moderation action log for audit trail
model ModerationLog {
  id           String           @id @default(cuid())
  targetUserId String
  adminUserId  String
  action       ModerationAction
  reason       String?          @db.Text
  reportId     String? // Optional link to triggering report

  // For suspensions
  suspensionDays Int?
  suspendedUntil DateTime?

  // Previous state (for potential reversal)
  previousStatus UserAccountStatus?

  createdAt DateTime @default(now())

  targetUser User @relation("ModerationActions", fields: [targetUserId], references: [id], onDelete: Cascade)

  @@index([targetUserId])
  @@index([adminUserId])
  @@index([createdAt])
  @@map("moderation_logs")
}

// =====================================================
// COMMUNITY SYSTEM
// =====================================================

enum CommunityPrivacy {
  PUBLIC // Anyone can join
  PRIVATE // Must request to join
  INVITE_ONLY // Only via invite link
}

enum CommunityMemberRole {
  OWNER // Creator, full control
  ADMIN // Can manage members & events
  MEMBER // Regular member
}

model City {
  id          String  @id @default(cuid())
  name        String  @unique // "Singapore", "Bangkok"
  slug        String  @unique // "singapore", "bangkok"
  country     String // "Singapore", "Thailand"
  countryCode String  @db.VarChar(2) // "SG", "TH"
  timezone    String // "Asia/Singapore", "Asia/Bangkok"
  latitude    Float
  longitude   Float
  coverImage  String?

  // Stats (denormalized for performance)
  communityCount Int @default(0)
  eventCount     Int @default(0)
  activeUsers    Int @default(0)

  // Launch status
  isLaunched Boolean   @default(false)
  launchedAt DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  communities Community[] @relation("CityCommunities")

  @@index([slug])
  @@index([isLaunched])
  @@map("cities")
}

model Community {
  id          String  @id @default(cuid())
  name        String
  slug        String  @unique
  description String? @db.Text
  coverImage  String?
  logoImage   String?

  // Location & Category
  cityId   String?
  category String // Primary activity type slug

  // Settings
  privacy    CommunityPrivacy @default(PUBLIC)
  isVerified Boolean          @default(false)
  isActive   Boolean          @default(true)

  // Social links
  instagramHandle String? @db.VarChar(100)
  websiteUrl      String? @db.VarChar(500)
  communityLink   String? @db.VarChar(500) // WhatsApp/Discord/Telegram

  // Stats (denormalized for performance)
  memberCount Int @default(0)
  eventCount  Int @default(0)

  // Ownership
  createdById String

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  city       City?             @relation("CityCommunities", fields: [cityId], references: [id])
  createdBy  User              @relation("CommunitiesOwned", fields: [createdById], references: [id])
  members    CommunityMember[]
  activities Activity[]        @relation("CommunityActivities")
  chat       CommunityChat?
  invites    CommunityInvite[]

  @@index([cityId])
  @@index([category])
  @@index([slug])
  @@index([createdById])
  @@index([isActive])
  @@map("communities")
}

model CommunityMember {
  id          String              @id @default(cuid())
  communityId String
  userId      String
  role        CommunityMemberRole @default(MEMBER)

  // Preferences
  notificationsOn Boolean @default(true)

  joinedAt DateTime @default(now())

  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)
  user      User      @relation("CommunityMemberships", fields: [userId], references: [id], onDelete: Cascade)

  @@unique([communityId, userId])
  @@index([communityId])
  @@index([userId])
  @@map("community_members")
}

model CommunityInvite {
  id          String @id @default(cuid())
  communityId String
  code        String @unique

  // Optional: specific invitee
  invitedEmail String?
  invitedById  String?

  // Limits
  maxUses   Int?
  usedCount Int       @default(0)
  expiresAt DateTime?

  createdAt DateTime @default(now())

  community Community @relation(fields: [communityId], references: [id], onDelete: Cascade)

  @@index([code])
  @@index([communityId])
  @@map("community_invites")
}

model CommunityChat {
  id          String @id @default(cuid())
  communityId String @unique

  createdAt     DateTime  @default(now())
  lastMessageAt DateTime?

  community Community          @relation(fields: [communityId], references: [id], onDelete: Cascade)
  messages  CommunityMessage[]

  @@map("community_chats")
}

model CommunityMessage {
  id       String @id @default(cuid())
  chatId   String
  senderId String
  content  String @db.Text

  createdAt DateTime @default(now())

  chat   CommunityChat @relation(fields: [chatId], references: [id], onDelete: Cascade)
  sender User          @relation("CommunityMessagesSent", fields: [senderId], references: [id], onDelete: Cascade)

  @@index([chatId, createdAt])
  @@index([senderId])
  @@map("community_messages")
}
